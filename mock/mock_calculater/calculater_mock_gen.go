// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Jinof/jobs-for-the-boys/proto/calculater (interfaces: CalculaterClient)

// Package mock_calculater is a generated GoMock package.
package mock_calculater

import (
        context "context"
        reflect "reflect"

        calculater "github.com/Jinof/jobs-for-the-boys/proto/calculater"
        gomock "go.uber.org/mock/gomock"
        grpc "google.golang.org/grpc"
)

// MockCalculaterClient is a mock of CalculaterClient interface.
type MockCalculaterClient struct {
        ctrl     *gomock.Controller
        recorder *MockCalculaterClientMockRecorder
}

// MockCalculaterClientMockRecorder is the mock recorder for MockCalculaterClient.
type MockCalculaterClientMockRecorder struct {
        mock *MockCalculaterClient
}

// NewMockCalculaterClient creates a new mock instance.
func NewMockCalculaterClient(ctrl *gomock.Controller) *MockCalculaterClient {
        mock := &MockCalculaterClient{ctrl: ctrl}
        mock.recorder = &MockCalculaterClientMockRecorder{mock}
        return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCalculaterClient) EXPECT() *MockCalculaterClientMockRecorder {
        return m.recorder
}

// Encode mocks base method.
func (m *MockCalculaterClient) Encode(arg0 context.Context, arg1 *calculater.EncodeRequest, arg2 ...grpc.CallOption) (*calculater.EncodeResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "Encode", varargs...)
        ret0, _ := ret[0].(*calculater.EncodeResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// Encode indicates an expected call of Encode.
func (mr *MockCalculaterClientMockRecorder) Encode(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encode", reflect.TypeOf((*MockCalculaterClient)(nil).Encode), varargs...)
}

// FeedForward mocks base method.
func (m *MockCalculaterClient) FeedForward(arg0 context.Context, arg1 *calculater.FeedForwardRequest, arg2 ...grpc.CallOption) (*calculater.FeedForwardResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "FeedForward", varargs...)
        ret0, _ := ret[0].(*calculater.FeedForwardResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// FeedForward indicates an expected call of FeedForward.
func (mr *MockCalculaterClientMockRecorder) FeedForward(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FeedForward", reflect.TypeOf((*MockCalculaterClient)(nil).FeedForward), varargs...)
}

// GetModelByPath mocks base method.
func (m *MockCalculaterClient) GetModelByPath(arg0 context.Context, arg1 *calculater.GetModelByPathRequest, arg2 ...grpc.CallOption) (*calculater.GetModelByPathResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "GetModelByPath", varargs...)
        ret0, _ := ret[0].(*calculater.GetModelByPathResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// GetModelByPath indicates an expected call of GetModelByPath.
func (mr *MockCalculaterClientMockRecorder) GetModelByPath(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModelByPath", reflect.TypeOf((*MockCalculaterClient)(nil).GetModelByPath), varargs...)
}

// LoadModel mocks base method.
func (m *MockCalculaterClient) LoadModel(arg0 context.Context, arg1 *calculater.LoadModelRequest, arg2 ...grpc.CallOption) (*calculater.LoadModelResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "LoadModel", varargs...)
        ret0, _ := ret[0].(*calculater.LoadModelResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// LoadModel indicates an expected call of LoadModel.
func (mr *MockCalculaterClientMockRecorder) LoadModel(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadModel", reflect.TypeOf((*MockCalculaterClient)(nil).LoadModel), varargs...)
}

// Out mocks base method.
func (m *MockCalculaterClient) Out(arg0 context.Context, arg1 *calculater.OutRequest, arg2 ...grpc.CallOption) (*calculater.OutResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "Out", varargs...)
        ret0, _ := ret[0].(*calculater.OutResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// Out indicates an expected call of Out.
func (mr *MockCalculaterClientMockRecorder) Out(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Out", reflect.TypeOf((*MockCalculaterClient)(nil).Out), varargs...)
}

// PreProcess mocks base method.
func (m *MockCalculaterClient) PreProcess(arg0 context.Context, arg1 *calculater.PreProcessRequest, arg2 ...grpc.CallOption) (*calculater.PreProcessResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "PreProcess", varargs...)
        ret0, _ := ret[0].(*calculater.PreProcessResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// PreProcess indicates an expected call of PreProcess.
func (mr *MockCalculaterClientMockRecorder) PreProcess(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreProcess", reflect.TypeOf((*MockCalculaterClient)(nil).PreProcess), varargs...)
}

// Proj mocks base method.
func (m *MockCalculaterClient) Proj(arg0 context.Context, arg1 *calculater.ProjRequest, arg2 ...grpc.CallOption) (*calculater.ProjResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "Proj", varargs...)
        ret0, _ := ret[0].(*calculater.ProjResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// Proj indicates an expected call of Proj.
func (mr *MockCalculaterClientMockRecorder) Proj(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Proj", reflect.TypeOf((*MockCalculaterClient)(nil).Proj), varargs...)
}

// RotrayEmb mocks base method.
func (m *MockCalculaterClient) RotrayEmb(arg0 context.Context, arg1 *calculater.RotrayEmbRequest, arg2 ...grpc.CallOption) (*calculater.RotrayEmbResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "RotrayEmb", varargs...)
        ret0, _ := ret[0].(*calculater.RotrayEmbResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// RotrayEmb indicates an expected call of RotrayEmb.
func (mr *MockCalculaterClientMockRecorder) RotrayEmb(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RotrayEmb", reflect.TypeOf((*MockCalculaterClient)(nil).RotrayEmb), varargs...)
}

// Score mocks base method.
func (m *MockCalculaterClient) Score(arg0 context.Context, arg1 *calculater.ScoreRequest, arg2 ...grpc.CallOption) (*calculater.ScoreResponse, error) {
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1}
        for _, a := range arg2 {
                varargs = append(varargs, a)
        }
        ret := m.ctrl.Call(m, "Score", varargs...)
        ret0, _ := ret[0].(*calculater.ScoreResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// Score indicates an expected call of Score.
func (mr *MockCalculaterClientMockRecorder) Score(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1}, arg2...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Score", reflect.TypeOf((*MockCalculaterClient)(nil).Score), varargs...)
}