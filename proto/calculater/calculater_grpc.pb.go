// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.23.4
// source: proto/calculater/calculater.proto

package calculater

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CalculaterClient is the client API for Calculater service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CalculaterClient interface {
	// 请求服务器端本地 RPC
	GetModelByPath(ctx context.Context, in *GetModelByPathRequest, opts ...grpc.CallOption) (*GetModelByPathResponse, error)
	Encode(ctx context.Context, in *EncodeRequest, opts ...grpc.CallOption) (*EncodeResponse, error)
	PreProcess(ctx context.Context, in *PreProcessRequest, opts ...grpc.CallOption) (*PreProcessResponse, error)
	RotrayEmb(ctx context.Context, in *RotrayEmbRequest, opts ...grpc.CallOption) (*RotrayEmbResponse, error)
	// 请求客户端本地 RPC
	LoadModel(ctx context.Context, in *LoadModelRequest, opts ...grpc.CallOption) (*LoadModelResponse, error)
	Proj(ctx context.Context, in *ProjRequest, opts ...grpc.CallOption) (*ProjResponse, error)
	Score(ctx context.Context, in *ScoreRequest, opts ...grpc.CallOption) (*ScoreResponse, error)
	FeedForward(ctx context.Context, in *FeedForwardRequest, opts ...grpc.CallOption) (*FeedForwardResponse, error)
	Out(ctx context.Context, in *OutRequest, opts ...grpc.CallOption) (*OutResponse, error)
}

type calculaterClient struct {
	cc grpc.ClientConnInterface
}

func NewCalculaterClient(cc grpc.ClientConnInterface) CalculaterClient {
	return &calculaterClient{cc}
}

func (c *calculaterClient) GetModelByPath(ctx context.Context, in *GetModelByPathRequest, opts ...grpc.CallOption) (*GetModelByPathResponse, error) {
	out := new(GetModelByPathResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/GetModelByPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) Encode(ctx context.Context, in *EncodeRequest, opts ...grpc.CallOption) (*EncodeResponse, error) {
	out := new(EncodeResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/Encode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) PreProcess(ctx context.Context, in *PreProcessRequest, opts ...grpc.CallOption) (*PreProcessResponse, error) {
	out := new(PreProcessResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/PreProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) RotrayEmb(ctx context.Context, in *RotrayEmbRequest, opts ...grpc.CallOption) (*RotrayEmbResponse, error) {
	out := new(RotrayEmbResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/RotrayEmb", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) LoadModel(ctx context.Context, in *LoadModelRequest, opts ...grpc.CallOption) (*LoadModelResponse, error) {
	out := new(LoadModelResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/LoadModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) Proj(ctx context.Context, in *ProjRequest, opts ...grpc.CallOption) (*ProjResponse, error) {
	out := new(ProjResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/Proj", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) Score(ctx context.Context, in *ScoreRequest, opts ...grpc.CallOption) (*ScoreResponse, error) {
	out := new(ScoreResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/Score", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) FeedForward(ctx context.Context, in *FeedForwardRequest, opts ...grpc.CallOption) (*FeedForwardResponse, error) {
	out := new(FeedForwardResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/FeedForward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calculaterClient) Out(ctx context.Context, in *OutRequest, opts ...grpc.CallOption) (*OutResponse, error) {
	out := new(OutResponse)
	err := c.cc.Invoke(ctx, "/calculater.Calculater/Out", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalculaterServer is the server API for Calculater service.
// All implementations must embed UnimplementedCalculaterServer
// for forward compatibility
type CalculaterServer interface {
	// 请求服务器端本地 RPC
	GetModelByPath(context.Context, *GetModelByPathRequest) (*GetModelByPathResponse, error)
	Encode(context.Context, *EncodeRequest) (*EncodeResponse, error)
	PreProcess(context.Context, *PreProcessRequest) (*PreProcessResponse, error)
	RotrayEmb(context.Context, *RotrayEmbRequest) (*RotrayEmbResponse, error)
	// 请求客户端本地 RPC
	LoadModel(context.Context, *LoadModelRequest) (*LoadModelResponse, error)
	Proj(context.Context, *ProjRequest) (*ProjResponse, error)
	Score(context.Context, *ScoreRequest) (*ScoreResponse, error)
	FeedForward(context.Context, *FeedForwardRequest) (*FeedForwardResponse, error)
	Out(context.Context, *OutRequest) (*OutResponse, error)
	mustEmbedUnimplementedCalculaterServer()
}

// UnimplementedCalculaterServer must be embedded to have forward compatible implementations.
type UnimplementedCalculaterServer struct {
}

func (UnimplementedCalculaterServer) GetModelByPath(context.Context, *GetModelByPathRequest) (*GetModelByPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelByPath not implemented")
}
func (UnimplementedCalculaterServer) Encode(context.Context, *EncodeRequest) (*EncodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encode not implemented")
}
func (UnimplementedCalculaterServer) PreProcess(context.Context, *PreProcessRequest) (*PreProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreProcess not implemented")
}
func (UnimplementedCalculaterServer) RotrayEmb(context.Context, *RotrayEmbRequest) (*RotrayEmbResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotrayEmb not implemented")
}
func (UnimplementedCalculaterServer) LoadModel(context.Context, *LoadModelRequest) (*LoadModelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadModel not implemented")
}
func (UnimplementedCalculaterServer) Proj(context.Context, *ProjRequest) (*ProjResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Proj not implemented")
}
func (UnimplementedCalculaterServer) Score(context.Context, *ScoreRequest) (*ScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Score not implemented")
}
func (UnimplementedCalculaterServer) FeedForward(context.Context, *FeedForwardRequest) (*FeedForwardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedForward not implemented")
}
func (UnimplementedCalculaterServer) Out(context.Context, *OutRequest) (*OutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Out not implemented")
}
func (UnimplementedCalculaterServer) mustEmbedUnimplementedCalculaterServer() {}

// UnsafeCalculaterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CalculaterServer will
// result in compilation errors.
type UnsafeCalculaterServer interface {
	mustEmbedUnimplementedCalculaterServer()
}

func RegisterCalculaterServer(s grpc.ServiceRegistrar, srv CalculaterServer) {
	s.RegisterService(&Calculater_ServiceDesc, srv)
}

func _Calculater_GetModelByPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelByPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).GetModelByPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/GetModelByPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).GetModelByPath(ctx, req.(*GetModelByPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_Encode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).Encode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/Encode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).Encode(ctx, req.(*EncodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_PreProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).PreProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/PreProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).PreProcess(ctx, req.(*PreProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_RotrayEmb_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotrayEmbRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).RotrayEmb(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/RotrayEmb",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).RotrayEmb(ctx, req.(*RotrayEmbRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_LoadModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).LoadModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/LoadModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).LoadModel(ctx, req.(*LoadModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_Proj_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).Proj(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/Proj",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).Proj(ctx, req.(*ProjRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_Score_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).Score(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/Score",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).Score(ctx, req.(*ScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_FeedForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedForwardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).FeedForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/FeedForward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).FeedForward(ctx, req.(*FeedForwardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Calculater_Out_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalculaterServer).Out(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calculater.Calculater/Out",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalculaterServer).Out(ctx, req.(*OutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Calculater_ServiceDesc is the grpc.ServiceDesc for Calculater service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Calculater_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "calculater.Calculater",
	HandlerType: (*CalculaterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetModelByPath",
			Handler:    _Calculater_GetModelByPath_Handler,
		},
		{
			MethodName: "Encode",
			Handler:    _Calculater_Encode_Handler,
		},
		{
			MethodName: "PreProcess",
			Handler:    _Calculater_PreProcess_Handler,
		},
		{
			MethodName: "RotrayEmb",
			Handler:    _Calculater_RotrayEmb_Handler,
		},
		{
			MethodName: "LoadModel",
			Handler:    _Calculater_LoadModel_Handler,
		},
		{
			MethodName: "Proj",
			Handler:    _Calculater_Proj_Handler,
		},
		{
			MethodName: "Score",
			Handler:    _Calculater_Score_Handler,
		},
		{
			MethodName: "FeedForward",
			Handler:    _Calculater_FeedForward_Handler,
		},
		{
			MethodName: "Out",
			Handler:    _Calculater_Out_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/calculater/calculater.proto",
}
